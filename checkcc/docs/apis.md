### File

Function | Arguments | Returns | Optional arguments
-- | -- | -- | --
**fileExists** | filename as Text | YN
**File** | fileName as Text | File | append (=no)
**read** | file as File | Text | lines (=0), bytes (=0)
**read** | | Text | lines (=0), bytes (=0), path (="stdin")
**eof** | file as File | YN
**write** | data as ... | Integer | file (=stdout), eol (=os.eol)

The `write` function is quite special: it is available with all built-in types for the first argument, and also autogenerated for each user-defined type which has the `str` function defined. It is also the standard way to print anything in F+, since leaving out the `file=` argument implies `stdout`.

Files are created on disk when you use the `File` constructor, so call the constructor only when you want this. Otherwise, use the `fileExists` function first to be sure.

How can `read` return binary when needed? (use `binread` or `readBinary`)

Global | Type | Notes
-- | -- | --
stdout | File | Standard output stream
stdin | File | Standard input stream (read-only)
stderr | File | Standard error output stream

Property | Type | Notes
-- | -- | --| --
size [**get**] | Integer |
modified [**get**]|DateTime |
accessed [**get**]|DateTime |
created [**get**]| DateTime |


### Regex

Function | Arguments | Returns | Optional arguments
-- | -- | --| --
_compile | reStr as String | _RegexProg |
match | source as String, regex as _RegexProg | RegexMatch[] |
contains | source as String, regex as _RegexProg | YesOrNo |
replace | source as String, replacement as String, matches as RegexMatch[]| String

Note that _RegexProg is transparent on the F+ side, i.e. you make a match call as follows:
```vb
var source as Text = read("words.dat")
var re as Regex = `([a-z]+)`
var m as RegexMatch = match(source, regex = re)
var repl as Text = replace(source, "_\1_", m)
```

### DateTime
Function | Arguments | Returns | Optional arguments
-- | -- | --| --
**DateTime** | (year, month, day) as Integer | DateTime | (hour, minute, second) as Integer
**add** | base as DateTime, diff as Duration | DateTime
**convert** | base as DateTime, zone as TimeZone | DateTime

Property | Type | Notes
-- | -- | --| --
year |Integer | 32-bit signed
month |Integer |
day |Integer |
hour |Integer |
minute |Integer |
second |Integer |
dayOfWeek [**get**] |Integer |
dayOfYear [**get**] |Integer |
zone | Integer/TimeZone? | -24 to +24 (30min increments from UTC)
isDST |YN |
unix  [**get**]|Integer | Seconds since epoch

### TimeZone
Function | Arguments | Returns | Optional arguments
-- | -- | --| --
**TimeZone** | label as Text | TimeZone
**add** | zone as TimeZone, offset as Integer | TimeZone

Property | Type | Notes
-- | -- | --| --
name | Text |
abbrev | Text |
repr | Text |  e.g. +0530 or -0600

### Duration


### Colour


### Resource?